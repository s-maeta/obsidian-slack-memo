# TASK-401: 自動同期スケジューラー - 要件定義

## 概要

Obsidian Slack同期プラグインに自動同期機能を実装します。指定した間隔で自動的にSlackから新しいメッセージを取得し、Obsidianのvaultに保存する機能を提供します。

## 主要要件

### 1. 自動同期スケジューラー

#### 1.1 定期実行機能
- **setInterval**ベースでの定期実行
- ユーザー設定可能な同期間隔（1分〜60分）
- デフォルト間隔：5分
- プラグインがロードされたタイミングでスケジューラー開始

#### 1.2 初回同期
- Obsidian起動時の初回同期実行
- 設定が有効な場合のみ初回同期を実行
- 初回同期の成功/失敗状態を記録

#### 1.3 バックグラウンド実行
- UIをブロックしない非同期処理
- 同期中でもObsidianの他の操作を阻害しない
- ユーザーの操作に対する応答性を保持

### 2. 同期競合の防止

#### 2.1 重複実行の防止
- 同期処理中は新しい同期を開始しない
- 同期状態フラグによる排他制御
- 手動同期と自動同期の競合回避

#### 2.2 同期時間管理
- 前回同期完了時刻の記録
- 最小間隔制限（1分未満の連続実行を防止）
- 長時間同期の検出とタイムアウト処理

### 3. 設定連携

#### 3.1 設定反映
- プラグイン設定の`autoSync`フラグに連動
- 設定の`syncInterval`値を動的に反映
- 設定変更時のスケジューラー再起動

#### 3.2 設定検証
- Slackトークンの有効性確認
- デフォルトチャンネル設定の検証
- 不正な設定時は自動同期を停止

### 4. エラーハンドリング

#### 4.1 ネットワークエラー対応
- API呼び出し失敗時のリトライ機構
- 最大3回のリトライ実行
- 指数バックオフによるリトライ間隔調整

#### 4.2 エラー通知
- 同期エラーの通知レベル制御
- 連続エラー発生時のアラート
- エラー内容の詳細ログ出力

### 5. パフォーマンス要件

#### 5.1 リソース効率
- メモリ使用量の最小化
- CPU使用率の低減
- 不要なタイマーの適切なクリーンアップ

#### 5.2 応答性
- スケジューラー開始/停止の即座反映
- 設定変更の即時適用
- プラグイン無効化時の確実な停止

## 非機能要件

### パフォーマンス
- 自動同期1回あたり最大30秒以内
- スケジューラー開始時間：100ms以内
- 設定変更反映時間：200ms以内

### 信頼性
- 連続稼働時間：24時間以上
- エラー発生時の自動復旧機能
- プラグイン再起動時の状態復元

### 保守性
- 設定可能なパラメータの外部化
- ログ出力による動作状況の追跡
- テスト可能な疎結合設計

## インターフェース設計

### AutoSyncScheduler クラス

```typescript
interface AutoSyncScheduler {
  // スケジューラー制御
  start(): void;
  stop(): void;
  restart(): void;
  
  // 状態取得
  isRunning(): boolean;
  getLastSyncTime(): Date | null;
  getNextSyncTime(): Date | null;
  
  // 設定更新
  updateInterval(intervalMs: number): void;
  updateSettings(settings: SlackSyncSettings): void;
  
  // 同期実行
  forceSyncNow(): Promise<void>;
  
  // イベント
  onSyncStart?: (event: SyncStartEvent) => void;
  onSyncComplete?: (event: SyncCompleteEvent) => void;
  onSyncError?: (event: SyncErrorEvent) => void;
}
```

### 設定インターフェース

```typescript
interface AutoSyncSettings {
  enabled: boolean;              // 自動同期の有効/無効
  intervalMs: number;           // 同期間隔（ミリ秒）
  initialSyncOnStartup: boolean; // 起動時初回同期
  maxRetryCount: number;        // 最大リトライ回数
  retryBackoffMs: number;       // リトライ間隔
  syncTimeout: number;          // 同期タイムアウト
}
```

## ユースケース

### UC-1: 自動同期の開始
1. ユーザーが自動同期を有効にする
2. プラグインがスケジューラーを開始
3. 初回同期を実行（設定により）
4. 指定間隔で定期同期を開始

### UC-2: 定期同期の実行
1. 設定された間隔が経過
2. 同期状態を確認（重複防止）
3. バックグラウンドで同期実行
4. 結果をユーザーに通知

### UC-3: 同期競合の回避
1. 手動同期が開始される
2. 自動同期がスケジュールされる
3. 競合を検出して自動同期を延期
4. 手動同期完了後に自動同期を再開

### UC-4: エラー時のリトライ
1. 自動同期中にネットワークエラー発生
2. エラーを検出してリトライを開始
3. 指数バックオフでリトライ間隔を調整
4. 最大回数失敗時にユーザーに通知

### UC-5: 設定変更の反映
1. ユーザーが同期間隔を変更
2. スケジューラーが設定変更を検出
3. 現在の同期を中断せずに新設定を適用
4. 次回同期から新間隔で実行

## 受け入れ基準

### 基本機能
- [ ] 設定した間隔で自動同期が実行される
- [ ] プラグイン起動時に初回同期が実行される
- [ ] 自動同期の有効/無効が即座に反映される
- [ ] 同期間隔の変更が次回同期から反映される

### 競合防止
- [ ] 手動同期中は自動同期が延期される
- [ ] 自動同期中は新しい自動同期が開始されない
- [ ] 複数の自動同期が並行実行されない

### エラーハンドリング
- [ ] ネットワークエラー時に適切にリトライされる
- [ ] 連続エラー時にユーザーに通知される
- [ ] エラー発生後も自動同期が継続される

### パフォーマンス
- [ ] 自動同期がObsidianの操作を阻害しない
- [ ] メモリリークが発生しない
- [ ] プラグイン無効化時にリソースが解放される

### 設定連携
- [ ] プラグイン設定の変更が即座に反映される
- [ ] 不正な設定時は適切なエラーメッセージを表示
- [ ] 設定復元時に前回の状態を再開する

## 実装制約

- Obsidian Plugin APIの制約を考慮
- Node.js setInterval/clearIntervalを使用
- 既存のSyncStatusManagerとの連携
- 既存のSlackAPIClientとの統合
- TypeScriptの型安全性を保持

## テスト戦略

- 単体テスト：スケジューラーロジックの検証
- 統合テスト：実際の同期フローの確認
- モックテスト：タイマー処理の検証
- エラーテスト：異常系の動作確認

## 関連ドキュメント

- REQ-201: 自動化機能要件
- REQ-006: パフォーマンス要件
- TASK-103: 差分同期ロジック実装
- TASK-302: 同期状態表示UI